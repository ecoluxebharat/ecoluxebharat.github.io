<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- viewport-fit=cover to respect safe-area insets on phones -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Temporarily Down for Maintenance</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap"
    rel="stylesheet"
  />

  <style>
    :root {
      --primary-color: #1a535c;
      --secondary-color: #287680;
      --accent-color: #4ecdc4;
      --text-color: #f7fff7;
      --shadow-color: rgba(0, 0, 0, 0.2);
      --ui-bg: rgba(255, 255, 255, 0.06);
    }

    * { box-sizing: border-box; }

    body {
      font-family: 'Inter', sans-serif;
      margin: 0;
      color: var(--text-color);
      background: radial-gradient(circle at 10% 20%, var(--primary-color) 0%, var(--secondary-color) 100%);
      padding:
        max(16px, env(safe-area-inset-top))
        max(16px, env(safe-area-inset-right))
        max(16px, env(safe-area-inset-bottom))
        max(16px, env(safe-area-inset-left));
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 18px;
      min-height: 100svh;
      animation: fadeIn 0.8s ease-in-out;
    }

    .container {
      width: 100%;
      max-width: 720px;
      border-radius: 20px;
      background-color: var(--secondary-color);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 10px 30px var(--shadow-color);
      backdrop-filter: blur(10px);
      padding: 2.25rem 1.25rem;
      text-align: center;
    }

    .icon { font-size: 3rem; color: var(--accent-color); margin-bottom: 0.75rem; animation: pulse 2s infinite; }
    h1 { margin: 0 0 0.5rem; font-size: clamp(1.6rem, 3.5vw, 2.2rem); }
    p { margin: 0.25rem 0 1rem; font-size: clamp(0.95rem, 2.6vw, 1.05rem); line-height: 1.6; opacity: 0.95; }

    .countdown {
      display: inline-block;
      margin-top: 0.75rem;
      padding: 0.7rem 0.9rem;
      border-radius: 12px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.08);
      color: var(--accent-color);
      font-weight: 700;
      font-size: clamp(1rem, 3.2vw, 1.2rem);
      min-width: 240px;
    }
    .countdown span { display: inline-block; margin: 0 0.45rem; }
    .countdown .label { display: block; font-size: 0.75rem; opacity: 0.7; margin-top: 0.15rem; }

    .contact-link {
      color: var(--accent-color);
      font-weight: 700;
      text-decoration: none;
      border-bottom: 2px solid transparent;
      transition: color 0.2s, border-color 0.2s;
      padding-bottom: 2px;
    }
    .contact-link:hover { color: #2dbeb5; border-color: #2dbeb5; }

    /* Game card */
    .game-card {
      width: 100%;
      max-width: 900px;
      background: linear-gradient(180deg, #0f373b, #164a50);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      box-shadow: 0 10px 30px var(--shadow-color);
      padding: 12px;
    }

    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin: 2px 4px 10px;
      flex-wrap: wrap;
    }

    .game-title { margin: 0; font-size: 1rem; opacity: 0.9; letter-spacing: 0.2px; }

    .controls { display: flex; gap: 8px; flex-wrap: wrap; }

    .btn {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.15);
      background: var(--ui-bg);
      color: var(--text-color);
      padding: 8px 12px;
      border-radius: 10px;
      font: 600 0.9rem 'Inter', sans-serif;
      cursor: pointer;
      user-select: none;
      transition: transform 0.12s ease, background 0.2s ease, border-color 0.2s ease;
      min-height: 40px;
    }
    .btn:hover { transform: translateY(-1px); background: rgba(255,255,255,0.09); border-color: rgba(255,255,255,0.25); }

    .canvas-wrap {
      position: relative;
      width: 100%;
      aspect-ratio: 2 / 1;
      background: #287680;
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid var(--accent-color);
    }

    @media (max-width: 680px) {
      .canvas-wrap {
        aspect-ratio: auto;
        height: clamp(360px, 62svh, 78svh);
      }
      .game-header .controls { display: none; }
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .hud {
      position: absolute;
      top: calc(10px + env(safe-area-inset-top));
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      color: var(--text-color);
      font-weight: 700;
      text-shadow: 0 2px 6px rgba(0, 0, 0, 0.35);
    }
    .hud .score, .hud .hi { font-size: clamp(0.9rem, 2.6vw, 1.05rem); }

    /* Mobile controls below the canvas */
    .mobile-controls {
      display: none;
      gap: 10px;
      justify-content: center;
      margin-top: 10px;
    }
    @media (max-width: 680px) {
      .mobile-controls { display: flex; }
    }
    .action-button {
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.35);
      color: var(--text-color);
      border-radius: 12px;
      backdrop-filter: blur(6px);
      font: 700 1rem 'Inter', sans-serif;
      padding: 12px 16px;
      min-height: 52px;
      min-width: clamp(110px, 30vw, 220px);
    }
    #jumpBtn { flex: 1 1 auto; min-width: clamp(150px, 44vw, 280px); }

    .center-overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      text-align: center;
      background: rgba(0,0,0,0.45);
      color: var(--text-color);
      padding: 20px;
    }
    .center-overlay.show { display: flex; }

    .overlay-card {
      background: rgba(10, 25, 27, 0.78);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: clamp(14px, 3.2vw, 18px);
      width: min(92%, 520px);
    }
    .overlay-title { margin: 0 0 6px; font-size: clamp(1.15rem, 3.8vw, 1.3rem); }
    .overlay-text { margin: 8px 0 12px; font-size: clamp(0.95rem, 3vw, 1.05rem); line-height: 1.6; opacity: 0.95; }

    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.04); } 100% { transform: scale(1); } }
	
	/* =========================================
   Premium Logo Styling with Soft White Glow
   ========================================= */

.logo {
  display: block;
  margin: 0 auto 16px;
  width: 100%;
  max-width: 200px;            /* Desktop size */
  height: auto;
  object-fit: contain;

  /* Premium white glow (edge-aware) */
  filter:
    drop-shadow(0 0 4px rgba(255, 255, 255, 0.55))
    drop-shadow(0 0 12px rgba(255, 255, 255, 0.32))
    drop-shadow(0 0 22px rgba(255, 255, 255, 0.18));

  /* Smooth rendering */
  will-change: filter;
  backface-visibility: hidden;

  /* Subtle entrance */
  animation: logoFadeIn 0.9s ease-out,
             logoGlow 3.6s ease-in-out infinite;
}

/* Tablets / small laptops */
@media (max-width: 900px) {
  .logo {
    max-width: 170px;
  }
}

/* Mobile phones */
@media (max-width: 680px) {
  .logo {
    max-width: 140px;

    /* Slightly softer glow for small screens */
    filter:
      drop-shadow(0 0 3px rgba(255, 255, 255, 0.45))
      drop-shadow(0 0 10px rgba(255, 255, 255, 0.26))
      drop-shadow(0 0 18px rgba(255, 255, 255, 0.14));
  }
}


/* Very small phones */
@media (max-width: 420px) {
  .logo {
    max-width: 120px;
  }
}

/* -----------------------------------------
   Animations
------------------------------------------ */

@keyframes logoFadeIn {
  from {
    opacity: 0;
    transform: translateY(-6px) scale(0.98);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

@keyframes logoGlow {
  0%, 100% {
    filter:
      drop-shadow(0 0 4px rgba(255, 255, 255, 0.5))
      drop-shadow(0 0 12px rgba(255, 255, 255, 0.3))
      drop-shadow(0 0 22px rgba(255, 255, 255, 0.18));
  }
  50% {
    filter:
      drop-shadow(0 0 7px rgba(255, 255, 255, 0.65))
      drop-shadow(0 0 18px rgba(255, 255, 255, 0.38))
      drop-shadow(0 0 32px rgba(255, 255, 255, 0.22));
  }
}

  </style>
</head>
<body>
  <div class="container" aria-live="polite">
	<img src="/logo.png" alt="EcoLuxe Bharat Logo" class="logo" class="icon" />
    <h1>Temporarily Under Maintenance</h1>
    <p>We're working on upgrades to improve the experience and will be back soon.</p>
    <div class="countdown" id="countdown"></div>
    <p>
      For urgent inquiries, please contact us at
      <a href="mailto:ecoluxebharat@gmail.com" class="contact-link">ecoluxebharat@gmail.com</a> <br>or give us a call on <a href="tel:+919211809192" class="contact-link" target="_blank">+91 92118 09192</a> & <a href="tel:+917982488375" class="contact-link" target="_blank">+91 79824 88375</a>
    </p>
  </div>

  <div class="game-card">
    <div class="game-header">
      <p class="game-title">Endless Runner Miniâ€‘Game</p>
      <div class="controls" role="group" aria-label="Game controls">
        <button class="btn" id="pauseBtn" type="button">Pause (P)</button>
        <button class="btn" id="muteBtn" type="button">Mute (M)</button>
        <button class="btn" id="restartBtn" type="button">Restart (R)</button>
      </div>
    </div>

    <div class="canvas-wrap" id="canvasWrap">
      <canvas id="gameCanvas"></canvas>

      <div class="hud" aria-hidden="true">
        <div class="score" id="scoreHud">Score: 0</div>
        <div class="hi" id="hiHud">Best: 0</div>
      </div>

      <div class="center-overlay" id="overlay">
        <div class="overlay-card">
          <h3 class="overlay-title" id="overlayTitle">Ready</h3>
          <p class="overlay-text" id="overlayText">
            Press <span class="kbd">Space</span> or tap Jump to start, jump over obstacles, and aim for a new high score. Use
            <span class="kbd">P</span> to pause and <span class="kbd">M</span> to mute.
          </p>
          <div class="controls" style="justify-content:center;">
            <button class="btn" id="overlayStart">Start</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Mobile controls below the canvas -->
    <div class="mobile-controls" role="group" aria-label="Mobile game controls">
      <button class="action-button" id="jumpBtn" type="button">Jump</button>
      <button class="action-button" id="pauseBtn2" type="button">Pause</button>
      <button class="action-button" id="restartBtn2" type="button">Restart</button>
    </div>
  </div>

  <script>
    // ----------------------------
    // Countdown
    // ----------------------------
    const countdownElement = document.getElementById('countdown');
    const maintenanceDate = new Date('November 1, 2025 00:00:00').getTime();
    const updateCountdown = () => {
      const now = Date.now();
      const distance = maintenanceDate - now;
      if (distance < 0) {
        countdownElement.textContent = "We're back!";
        return;
      }
      const days = Math.floor(distance / (1000 * 60 * 60 * 24));
      const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((distance % (1000 * 60)) / 1000);
      countdownElement.innerHTML = `
        <span>${days}<span class="label">Days</span></span>
        <span>${hours}<span class="label">Hours</span></span>
        <span>${minutes}<span class="label">Minutes</span></span>
        <span>${seconds}<span class="label">Seconds</span></span>
      `;
    };
    updateCountdown();
    setInterval(updateCountdown, 1000);

    // ----------------------------
    // Game
    // ----------------------------
    const canvas = document.getElementById('gameCanvas');
    const wrap = document.getElementById('canvasWrap');
    let ctx;

    // HUD
    const scoreHud = document.getElementById('scoreHud');
    const hiHud = document.getElementById('hiHud');

    // Overlay
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const overlayStart = document.getElementById('overlayStart');

    // Header controls
    const pauseBtn = document.getElementById('pauseBtn');
    const restartBtn = document.getElementById('restartBtn');
    const muteBtn = document.getElementById('muteBtn');

    // Mobile controls
    const jumpBtn = document.getElementById('jumpBtn');
    const pauseBtn2 = document.getElementById('pauseBtn2');
    const restartBtn2 = document.getElementById('restartBtn2');

    // Media queries for tuning
    const mqMobile = window.matchMedia('(max-width: 680px)');
    const mqCoarse = window.matchMedia('(pointer: coarse)');

    // HiDPI canvas
    function setupHiDPI() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = wrap.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      ctx = canvas.getContext('2d');
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr); // draw in CSS pixels for crispness
    }

    // Tunings
    const desktopTuning = {
      speed: 300,
      speedRamp: 0.025,
      gravity: 1600,
      jumpVel: -590,
      cadencePad: 0.28,     // base extra time between obstacles
      cadenceScale: 0.9,    // proportion of flight time to enforce
      cadenceTallBonus: 0.18,
      cadenceClampMin: 0.85,
      cadenceClampMax: 1.6
    };

    const mobileTuning = {
      speed: 240,
      speedRamp: 0.018,
      gravity: 1500,
      jumpVel: -620,
      cadencePad: 0.32,
      cadenceScale: 0.95,
      cadenceTallBonus: 0.2,
      cadenceClampMin: 0.9,
      cadenceClampMax: 1.8
    };

    function currentTuning() {
      const mobile = mqMobile.matches || mqCoarse.matches;
      return mobile ? mobileTuning : desktopTuning;
    }

    // Game state
    const state = {
      mode: 'ready', // 'ready' | 'playing' | 'paused' | 'gameover'
      muted: false,
      score: 0,
      hi: Number(localStorage.getItem('runner_hi') || 0),
      speed: 300,
      speedRamp: 0.025,
      gravity: 1600,
      jumpVel: -590,
      groundY: 0,
      time: 0,           // seconds since run start
      lastTs: 0,         // rAF timestamp
      nextSpawnAt: 1.0,  // next scheduled spawn time (sec)
      clouds: [],
      grounds: [],
      obstacles: [],
      particles: [],
      lastObstacleTall: false
    };

    // Player
    const player = { x: 60, y: 0, r: 16, vy: 0, jumping: false };

    // Audio
    let audioCtx = null;
    function beep(freq, dur, type = 'sine', vol = 0.03) {
      if (state.muted) return;
      try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type; o.frequency.value = freq; g.gain.value = vol;
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + dur);
      } catch {}
    }

    // Utils
    function rand(a, b) { return Math.random() * (b - a) + a; }
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function circleRectCollide(cx, cy, r, rx, ry, rw, rh) {
      const nx = clamp(cx, rx, rx + rw);
      const ny = clamp(cy, ry, ry + rh);
      const dx = cx - nx, dy = cy - ny;
      return (dx * dx + dy * dy) <= r * r;
    }

    // Spawners
    function spawnCloud(width) {
      const size = rand(30, 80);
      state.clouds.push({ x: width + rand(0, 200), y: rand(20, 120), w: size, h: size * 0.6, speed: rand(18, 40) });
    }
    function spawnGround(width) {
      const segW = rand(90, 160);
      state.grounds.push({ x: width + rand(0, 60), w: segW, h: 6, speed: state.speed * 0.9 });
    }

    // New: schedule next spawn using jump cadence and Poisson-like spacing
    function scheduleNextSpawn() {
      const t = currentTuning();
      const flight = 2 * Math.abs(state.jumpVel) / state.gravity; // s, jump up+down
      const tallBonus = state.lastObstacleTall ? t.cadenceTallBonus : 0;
      let minCadence = t.cadenceScale * flight + t.cadencePad + tallBonus;
      minCadence = clamp(minCadence, t.cadenceClampMin, t.cadenceClampMax);
      const maxCadence = minCadence + 0.55; // randomization window
      state.nextSpawnAt = state.time + rand(minCadence, maxCadence);
      state.lastObstacleTall = false; // reset until next spawn decides
    }

    function spawnObstacle(width) {
      const type = Math.random() < 0.5 ? 'cylinder' : 'box';
      const w = type === 'cylinder' ? rand(16, 26) : rand(20, 34);
      const h = type === 'cylinder' ? rand(24, 56) : rand(26, 44);
      // Keep small off-screen offset; spacing is handled by scheduler
      const x = width + rand(80, 160);
      const y = state.groundY - h;
      state.obstacles.push({ type, x, y, w, h, color: '#0f1a1c' });
      // Mark tall obstacles to add extra spacing next time
      state.lastObstacleTall = h >= 44;
    }

    function spawnDust(x, y, count = 8) {
      for (let i = 0; i < count; i++) {
        state.particles.push({ x: x + rand(-4, 4), y: y + rand(-2, 2), vx: rand(-60, 60), vy: rand(-120, -40), life: rand(0.25, 0.45) });
      }
    }

    // Resize
    function resize() {
      setupHiDPI();
      const cssH = wrap.clientHeight;
      state.groundY = cssH - 50;
      if (player.y === 0) player.y = state.groundY - player.r * 2;
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    // Drawing helpers
    function roundedRect(x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }

    function drawBackground(w, h, dt) {
      const g = ctx.createLinearGradient(0, 0, 0, h);
      g.addColorStop(0, '#1c5e66'); g.addColorStop(1, '#287680');
      ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);

      ctx.globalAlpha = 0.15; ctx.fillStyle = '#ffffff';
      for (let i = 0; i < 30; i++) {
        const px = (i * 31) % w, py = (i * 53) % Math.floor(h * 0.6);
        ctx.fillRect(px, py, 2, 2);
      }
      ctx.globalAlpha = 1;

      const cssW = wrap.clientWidth;
      for (const c of state.clouds) c.x -= c.speed * dt;
      state.clouds = state.clouds.filter(c => c.x + c.w > -10);

      const desiredClouds = (mqMobile.matches || mqCoarse.matches) ? 4 : 6;
      if (state.clouds.length < desiredClouds) spawnCloud(cssW);

      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      for (const c of state.clouds) { roundedRect(c.x, c.y, c.w, c.h, Math.min(12, c.h / 2)); ctx.fill(); }
    }

    function drawGround(w, dt) {
      ctx.fillStyle = '#f7fff7';
      ctx.fillRect(0, state.groundY - 2, w, 2);
      for (const g of state.grounds) g.x -= g.speed * dt;
      state.grounds = state.grounds.filter(g => g.x + g.w > -10);

      const desiredGrounds = (mqMobile.matches || mqCoarse.matches) ? 10 : 12;
      if (state.grounds.length < desiredGrounds) spawnGround(w);

      ctx.fillStyle = 'rgba(247,255,247,0.6)';
      for (const g of state.grounds) ctx.fillRect(g.x, state.groundY - g.h, g.w, g.h);
    }

    function drawPlayer() {
      ctx.fillStyle = '#f7fff7';
      ctx.beginPath();
      ctx.arc(player.x + player.r, player.y + player.r, player.r, 0, Math.PI * 2);
      ctx.fill();
      // Shadow
      ctx.globalAlpha = 0.15; ctx.fillStyle = '#000';
      const sw = player.r * 2.1;
      ctx.beginPath();
      ctx.ellipse(player.x + player.r, state.groundY - 4, sw * 0.6, sw * 0.25, 0, 0, Math.PI * 2);
      ctx.fill(); ctx.globalAlpha = 1;
    }

    function drawObstacle(o) {
      ctx.fillStyle = o.color;
      if (o.type === 'cylinder') {
        ctx.fillRect(o.x, o.y + o.w / 2, o.w, o.h);
        ctx.beginPath();
        ctx.ellipse(o.x + o.w / 2, o.y + o.w / 2, o.w / 2, o.w / 4, 0, 0, Math.PI * 2);
        ctx.fill();
      } else {
        roundedRect(o.x, o.y, o.w, o.h, Math.min(6, o.w * 0.25)); ctx.fill();
      }
    }

    function drawParticles(dt) {
      ctx.fillStyle = 'rgba(247,255,247,0.8)';
      for (const p of state.particles) {
        p.x += p.vx * dt; p.y += p.vy * dt; p.vy += state.gravity * 0.7 * dt; p.life -= dt;
        ctx.globalAlpha = Math.max(0, p.life * 2); ctx.fillRect(p.x, p.y, 2, 2);
      }
      ctx.globalAlpha = 1; state.particles = state.particles.filter(p => p.life > 0);
    }

    function update(dt) {
      const w = wrap.clientWidth;

      // Time
      state.time += dt;

      // Difficulty ramp (gentle)
      state.speed += state.speedRamp * state.speed * dt;

      // Spawning: schedule-driven with cadenced timing
      if (state.time >= state.nextSpawnAt) {
        spawnObstacle(w);
        scheduleNextSpawn();
      }

      // Player physics
      player.y += player.vy * dt;
      player.vy += state.gravity * dt;

      // Ground collision
      const floor = state.groundY - player.r * 2;
      if (player.y > floor) {
        if (player.jumping) spawnDust(player.x + player.r, state.groundY - 6, 10);
        player.y = floor; player.vy = 0; player.jumping = false;
      }

      // Obstacles
      for (const o of state.obstacles) o.x -= state.speed * dt;
      state.obstacles = state.obstacles.filter(o => o.x + o.w > -10);

      // Collisions
      const cx = player.x + player.r, cy = player.y + player.r;
      for (const o of state.obstacles) {
        if (circleRectCollide(cx, cy, player.r, o.x, o.y, o.w, o.h)) { gameOver(); return; }
      }

      // Score
      state.score += dt * 10;
      scoreHud.textContent = 'Score: ' + Math.floor(state.score);
      hiHud.textContent = 'Best: ' + Math.floor(state.hi);
    }

    function draw(dt) {
      const w = wrap.clientWidth, h = wrap.clientHeight;
      ctx.clearRect(0, 0, w, h);
      drawBackground(w, h, dt);
      drawGround(w, dt);
      for (const o of state.obstacles) drawObstacle(o);
      drawPlayer();
      drawParticles(dt);
    }

    let rafId = 0;
    function loop(ts) {
      if (state.mode !== 'playing') return;
      if (!state.lastTs) state.lastTs = ts;
      let dt = (ts - state.lastTs) / 1000; state.lastTs = ts;
      dt = Math.min(dt, 0.05);
      update(dt); draw(dt);
      rafId = requestAnimationFrame(loop);
    }

    function applyTuning(t) {
      state.speed = t.speed;
      state.speedRamp = t.speedRamp;
      state.gravity = t.gravity;
      state.jumpVel = t.jumpVel;
    }

    function startGame() {
      cancelAnimationFrame(rafId);
      state.mode = 'playing'; overlay.classList.remove('show');

      // Apply tuning
      applyTuning(currentTuning());

      // Reset
      state.score = 0;
      state.time = 0;
      state.lastTs = 0;
      state.obstacles = []; state.clouds = []; state.grounds = []; state.particles = [];
      state.lastObstacleTall = false;

      // Seed background
      const w = wrap.clientWidth;
      const mobile = mqMobile.matches || mqCoarse.matches;
      for (let i = 0; i < (mobile ? 3 : 6); i++) spawnCloud(w);
      for (let i = 0; i < (mobile ? 8 : 12); i++) spawnGround(w);

      // Player
      player.y = state.groundY - player.r * 2; player.vy = 0; player.jumping = false;

      // First spawn scheduled with a small grace period
      scheduleNextSpawn();
      state.nextSpawnAt = 0.7; // give the player a moment before the first obstacle

      rafId = requestAnimationFrame(loop);
    }

    function pauseGame() {
      if (state.mode === 'playing') {
        state.mode = 'paused';
        overlay.classList.add('show');
        overlayTitle.textContent = 'Paused';
        overlayText.innerHTML = 'Press <span class="kbd">P</span> or Pause to resume, <span class="kbd">R</span> to restart.';
      } else if (state.mode === 'paused') {
        state.mode = 'playing'; overlay.classList.remove('show'); state.lastTs = 0; rafId = requestAnimationFrame(loop);
      }
    }

    function gameOver() {
      state.mode = 'gameover'; cancelAnimationFrame(rafId);
      beep(180, 0.18, 'sawtooth', 0.04); spawnDust(player.x + player.r, state.groundY - 6, 16);
      if (state.score > state.hi) { state.hi = state.score; localStorage.setItem('runner_hi', String(Math.floor(state.hi))); }
      overlay.classList.add('show');
      overlayTitle.textContent = 'Game Over';
      overlayText.innerHTML = 'Final Score: <b>' + Math.floor(state.score) + '</b><br/>Press <span class="kbd">Space</span> or <span class="kbd">R</span> to restart.';
    }

    function jump() {
      if (state.mode === 'ready') { startGame(); return; }
      if (state.mode !== 'playing') return;
      if (!player.jumping) { player.vy = state.jumpVel; player.jumping = true; beep(440, 0.08, 'square', 0.03); }
    }
    function restart() { overlay.classList.remove('show'); startGame(); }
    function toggleMute() { state.muted = !state.muted; muteBtn.textContent = state.muted ? 'Unmute (M)' : 'Mute (M)'; }

    // Inputs
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { e.preventDefault(); if (state.mode === 'gameover') restart(); else jump(); }
      else if (e.code === 'KeyP') pauseGame();
      else if (e.code === 'KeyR') restart();
      else if (e.code === 'KeyM') toggleMute();
    });

    // Mobile controls
    jumpBtn.addEventListener('click', () => { if (state.mode === 'gameover') restart(); else jump(); });
    pauseBtn2.addEventListener('click', pauseGame);
    restartBtn2.addEventListener('click', restart);

    // Header controls
    pauseBtn?.addEventListener('click', pauseGame);
    restartBtn?.addEventListener('click', restart);
    muteBtn?.addEventListener('click', toggleMute);
    overlayStart.addEventListener('click', startGame);

    // Canvas pointer
    canvas.addEventListener('mousedown', () => { if (state.mode === 'gameover') restart(); else jump(); });
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); if (state.mode === 'gameover') restart(); else jump(); }, { passive: false });

    // Initialize overlay
    overlay.classList.add('show');
    overlayTitle.textContent = 'Ready';
    overlayText.innerHTML = 'Press <span class="kbd">Space</span> or tap Jump to start, jump over obstacles, and aim for a new high score.';
  </script>
</body>
</html>
